/*
 * Probing Routine Generator for Height Map
 * Generates G-code commands for the probing sequence
 */

import { HeightMapConfig, HeightMapData, HeightMapPoint } from '../definitions';
import { calculateProbeGrid } from './interpolation';

export interface ProbeRoutineConfig {
    zClearance: number;
    probeFeedRate: number;
    maxProbeDepth: number;
}

/**
 * Generate probe command for a single point
 */
export const generateProbePointCommands = (
    x: number,
    y: number,
    config: ProbeRoutineConfig,
): string[] => {
    const { zClearance, probeFeedRate, maxProbeDepth } = config;

    return [
        `; Probe point at X${x} Y${y}`,
        `G90 G0 Z${zClearance}`, // Raise to clearance height first
        `G90 G0 X${x} Y${y}`, // Move to XY position
        `G38.2 Z-${maxProbeDepth} F${probeFeedRate}`, // Probe down
        `G4 P0.1`, // Short dwell for probe debounce
        `%PROBE_Z=posz`, // Store probe Z position (variable syntax)
        `G90 G0 Z${zClearance}`, // Retract to clearance height
    ];
};

/**
 * Generate the complete probing routine G-code
 * Note: This returns the G-code commands that will be streamed to the machine
 * The actual probe result handling is done by the ProbeRunner component
 */
export const generateProbeRoutineGcode = (
    config: HeightMapConfig,
): { commands: string[]; probePoints: { x: number; y: number }[] } => {
    const probePoints = calculateProbeGrid(
        config.minX,
        config.maxX,
        config.minY,
        config.maxY,
        config.gridSpacing,
        config.usePointCount,
        config.pointCountX,
        config.pointCountY,
    );

    const commands: string[] = [
        '; Height Map Probing Routine',
        '; Generated by gSender Height Map Tool',
        `; Grid: X[${config.minX}, ${config.maxX}] Y[${config.minY}, ${config.maxY}]`,
        `; Total points: ${probePoints.length}`,
        '',
        'G21', // Set metric units
        'G90', // Absolute positioning
        `G0 Z${config.zClearance}`, // Initial retract to clearance height
        '',
    ];

    // Generate commands for each probe point
    for (let i = 0; i < probePoints.length; i++) {
        const point = probePoints[i];
        commands.push(`; Point ${i + 1} of ${probePoints.length}`);
        commands.push(...generateProbePointCommands(point.x, point.y, config));
        commands.push('');
    }

    // Return to starting position
    commands.push('; Return to start');
    commands.push(`G0 Z${config.zClearance}`);
    commands.push(`G0 X${config.minX} Y${config.minY}`);

    return { commands, probePoints };
};

/**
 * Generate commands for probing a single point
 * Used for step-by-step probing where we wait for each probe result
 */
export const generateSingleProbeCommand = (
    x: number,
    y: number,
    zClearance: number,
    probeFeedRate: number,
    maxProbeDepth: number,
): string => {
    // Return a single command string that will be executed
    // Order: 1) Raise to safe Z, 2) Move to XY position, 3) Probe down
    return [
        `G90 G0 Z${zClearance}`,
        `G90 G0 X${x.toFixed(3)} Y${y.toFixed(3)}`,
        `G38.2 Z-${maxProbeDepth} F${probeFeedRate}`,
    ].join('\n');
};

/**
 * Create a height map data structure from probe results
 */
export const createHeightMapFromProbeResults = (
    probePoints: { x: number; y: number }[],
    zValues: number[],
    config: HeightMapConfig,
    units: string = 'mm',
): HeightMapData => {
    if (probePoints.length !== zValues.length) {
        throw new Error('Probe points and Z values arrays must have the same length');
    }

    const points: HeightMapPoint[] = probePoints.map((point, index) => ({
        x: point.x,
        y: point.y,
        z: zValues[index],
    }));

    // Calculate actual resolution from the points
    const uniqueX = [...new Set(probePoints.map((p) => p.x))].sort((a, b) => a - b);
    const uniqueY = [...new Set(probePoints.map((p) => p.y))].sort((a, b) => a - b);

    const resX = uniqueX.length > 1 ? uniqueX[1] - uniqueX[0] : config.gridSpacing;
    const resY = uniqueY.length > 1 ? uniqueY[1] - uniqueY[0] : config.gridSpacing;

    return {
        bounds: {
            minX: config.minX,
            maxX: config.maxX,
            minY: config.minY,
            maxY: config.maxY,
        },
        resolution: {
            x: resX,
            y: resY,
        },
        points,
        createdAt: new Date().toISOString(),
        units,
    };
};

/**
 * Normalize Z values in height map relative to the minimum value
 * This makes the lowest point Z=0
 */
export const normalizeHeightMap = (mapData: HeightMapData): HeightMapData => {
    if (!mapData.points || mapData.points.length === 0) {
        return mapData;
    }

    const minZ = Math.min(...mapData.points.map((p) => p.z));

    return {
        ...mapData,
        points: mapData.points.map((p) => ({
            ...p,
            z: Number((p.z - minZ).toFixed(4)),
        })),
    };
};

/**
 * Validate height map data
 */
export const validateHeightMap = (
    mapData: HeightMapData | null,
): { valid: boolean; error?: string } => {
    if (!mapData) {
        return { valid: false, error: 'No height map data' };
    }

    if (!mapData.points || mapData.points.length === 0) {
        return { valid: false, error: 'Height map has no probe points' };
    }

    if (!mapData.bounds) {
        return { valid: false, error: 'Height map has no bounds defined' };
    }

    // Check for at least 4 points (minimum for bilinear interpolation)
    if (mapData.points.length < 4) {
        return { valid: false, error: 'Height map needs at least 4 probe points' };
    }

    // Check for valid grid structure
    const uniqueX = [...new Set(mapData.points.map((p) => p.x))];
    const uniqueY = [...new Set(mapData.points.map((p) => p.y))];

    if (uniqueX.length < 2 || uniqueY.length < 2) {
        return { valid: false, error: 'Height map needs at least 2x2 grid' };
    }

    return { valid: true };
};
